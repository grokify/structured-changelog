// Package renderer provides deterministic Markdown rendering for changelogs.
package renderer

import (
	"fmt"
	"regexp"
	"strings"

	"github.com/grokify/structured-changelog/changelog"
)

// githubRepoPattern matches GitHub repository URLs and extracts owner/repo.
var githubRepoPattern = regexp.MustCompile(`^https?://github\.com/([^/]+)/([^/]+?)(?:\.git)?/?$`)

// gitlabRepoPattern matches GitLab repository URLs and extracts the full project path.
// GitLab supports nested groups, so the path can be arbitrarily deep.
var gitlabRepoPattern = regexp.MustCompile(`^https?://gitlab\.com/(.+?)(?:\.git)?/?$`)

// RenderMarkdown renders a changelog to Keep a Changelog formatted Markdown.
// The output is deterministic: same input always produces identical output.
func RenderMarkdown(cl *changelog.Changelog) string {
	return RenderMarkdownWithOptions(cl, DefaultOptions())
}

// renderHeaderLine generates the changelog header line based on project settings.
// It includes references to Keep a Changelog, versioning scheme, commit convention,
// and Structured Changelog as appropriate.
func renderHeaderLine(cl *changelog.Changelog) string {
	var parts []string

	// Always include Keep a Changelog reference
	parts = append(parts, "The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.1.0/)")

	// Add versioning scheme based on the versioning field
	versioning := cl.Versioning
	if versioning == "" {
		versioning = changelog.VersioningSemVer // default
	}

	switch versioning {
	case changelog.VersioningSemVer:
		parts = append(parts, "this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html)")
	case changelog.VersioningCalVer:
		parts = append(parts, "this project uses [Calendar Versioning](https://calver.org/)")
	case changelog.VersioningCustom, changelog.VersioningNone:
		// No versioning line added
	}

	// Add commit convention if specified
	if cl.CommitConvention == changelog.CommitConventionConventional {
		parts = append(parts, "commits follow [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/)")
	}

	// Always include Structured Changelog reference
	parts = append(parts, "this changelog is generated by [Structured Changelog](https://github.com/grokify/structured-changelog)")

	// Join parts with appropriate punctuation
	if len(parts) == 1 {
		return parts[0] + ".\n"
	}

	var sb strings.Builder
	for i, part := range parts {
		if i == 0 {
			sb.WriteString(part)
		} else if i == len(parts)-1 {
			sb.WriteString(",\nand ")
			sb.WriteString(part)
		} else {
			sb.WriteString(",\n")
			sb.WriteString(part)
		}
	}
	sb.WriteString(".\n")
	return sb.String()
}

// renderContext holds context needed during rendering.
type renderContext struct {
	cl      *changelog.Changelog
	opts    Options
	baseURL string
	host    repoHost
}

// RenderMarkdownWithOptions renders a changelog with custom options.
func RenderMarkdownWithOptions(cl *changelog.Changelog, opts Options) string {
	var sb strings.Builder

	// Parse repository for linking
	baseURL, host := parseRepository(cl.Repository)
	ctx := renderContext{
		cl:      cl,
		opts:    opts,
		baseURL: baseURL,
		host:    host,
	}

	// Header
	sb.WriteString("# Changelog\n\n")
	sb.WriteString("All notable changes to this project will be documented in this file.\n\n")
	sb.WriteString(renderHeaderLine(cl))

	// Unreleased section
	// Always show if IncludeUnreleasedLink is enabled and there are releases to compare against
	if cl.Unreleased != nil && !cl.Unreleased.IsEmpty() {
		sb.WriteString("\n## [Unreleased]\n")
		renderReleaseContent(&sb, cl.Unreleased, ctx)
	} else if opts.IncludeUnreleasedLink && len(cl.Releases) > 0 {
		sb.WriteString("\n## [Unreleased]\n")
	}

	// Releases
	if opts.CompactMaintenanceReleases {
		renderReleasesWithGrouping(&sb, cl.Releases, ctx)
	} else {
		for _, release := range cl.Releases {
			sb.WriteString("\n")
			renderRelease(&sb, &release, ctx)
		}
	}

	// Reference links at bottom (for GitHub repositories)
	if opts.IncludeCompareLinks && cl.Repository != "" {
		if links := renderReferenceLinks(cl, opts.IncludeUnreleasedLink); links != "" {
			sb.WriteString("\n")
			sb.WriteString(links)
		}
	}

	return sb.String()
}

func renderRelease(sb *strings.Builder, r *changelog.Release, ctx renderContext) {
	// Version header
	if r.Yanked {
		fmt.Fprintf(sb, "## [%s] - %s [YANKED]\n", r.Version, r.Date)
	} else {
		fmt.Fprintf(sb, "## [%s] - %s\n", r.Version, r.Date)
	}

	renderReleaseContent(sb, r, ctx)
}

// renderReleasesWithGrouping renders releases, grouping consecutive maintenance-only
// releases into a single compact section.
func renderReleasesWithGrouping(sb *strings.Builder, releases []changelog.Release, ctx renderContext) {
	i := 0
	for i < len(releases) {
		release := &releases[i]

		// Check if this starts a run of maintenance-only releases
		if release.IsMaintenanceOnly() {
			// Find the end of the consecutive maintenance releases
			start := i
			for i < len(releases) && releases[i].IsMaintenanceOnly() {
				i++
			}
			end := i - 1 // inclusive

			// Render the group
			if start == end {
				// Single maintenance release - render normally but compact
				sb.WriteString("\n")
				renderMaintenanceRelease(sb, &releases[start], ctx)
			} else {
				// Multiple consecutive maintenance releases - group them
				renderMaintenanceGroup(sb, releases[start:end+1], ctx)
			}
		} else {
			// Regular release - render normally
			sb.WriteString("\n")
			renderRelease(sb, release, ctx)
			i++
		}
	}
}

// renderMaintenanceRelease renders a single maintenance release in compact form.
func renderMaintenanceRelease(sb *strings.Builder, r *changelog.Release, _ renderContext) {
	// Compact header with (Maintenance) suffix
	fmt.Fprintf(sb, "## [%s] - %s (Maintenance)\n\n", r.Version, r.Date)

	// Summarize what changed
	var types []string
	if len(r.Dependencies) > 0 {
		types = append(types, "dependency updates")
	}
	if len(r.Documentation) > 0 {
		types = append(types, "documentation")
	}
	if len(r.Build) > 0 {
		types = append(types, "build")
	}
	if len(r.Tests) > 0 {
		types = append(types, "tests")
	}
	if len(r.Internal) > 0 {
		types = append(types, "internal")
	}
	if len(r.Infrastructure) > 0 {
		types = append(types, "infrastructure")
	}
	if len(r.Observability) > 0 {
		types = append(types, "observability")
	}
	if len(r.Compliance) > 0 {
		types = append(types, "compliance")
	}
	if len(r.Contributors) > 0 {
		types = append(types, "contributors")
	}

	if len(types) > 0 {
		sb.WriteString(strings.Join(types, ", "))
		sb.WriteString("\n")
	}
}

// renderMaintenanceGroup renders a group of consecutive maintenance releases.
func renderMaintenanceGroup(sb *strings.Builder, releases []changelog.Release, _ renderContext) {
	if len(releases) == 0 {
		return
	}

	// releases are in reverse chronological order, so first is newest, last is oldest
	newest := &releases[0]
	oldest := &releases[len(releases)-1]

	sb.WriteString("\n")
	fmt.Fprintf(sb, "## Versions %s - %s (Maintenance)\n\n", oldest.Version, newest.Version)

	// Count total changes and summarize
	var depsCount, docsCount, buildCount, testsCount, otherCount int
	for i := range releases {
		r := &releases[i]
		depsCount += len(r.Dependencies)
		docsCount += len(r.Documentation)
		buildCount += len(r.Build)
		testsCount += len(r.Tests)
		otherCount += len(r.Internal) + len(r.Infrastructure) + len(r.Observability) + len(r.Compliance) + len(r.Contributors)
	}

	// Build summary line
	var parts []string
	if depsCount > 0 {
		parts = append(parts, fmt.Sprintf("%d dependency update(s)", depsCount))
	}
	if docsCount > 0 {
		parts = append(parts, fmt.Sprintf("%d documentation change(s)", docsCount))
	}
	if buildCount > 0 {
		parts = append(parts, fmt.Sprintf("%d build change(s)", buildCount))
	}
	if testsCount > 0 {
		parts = append(parts, fmt.Sprintf("%d test change(s)", testsCount))
	}
	if otherCount > 0 {
		parts = append(parts, fmt.Sprintf("%d other change(s)", otherCount))
	}

	fmt.Fprintf(sb, "%d releases: %s.\n", len(releases), strings.Join(parts, ", "))
}

func renderReleaseContent(sb *strings.Builder, r *changelog.Release, ctx renderContext) {
	// Render categories in canonical order, filtered by tier
	maxTier := ctx.opts.MaxTier
	if maxTier == "" {
		maxTier = changelog.TierOptional
	}

	for _, cat := range r.CategoriesFiltered(maxTier) {
		fmt.Fprintf(sb, "\n### %s\n\n", cat.Name)
		for _, entry := range cat.Entries {
			renderEntry(sb, &entry, ctx, cat.Name)
		}
	}
}

func renderEntry(sb *strings.Builder, e *changelog.Entry, ctx renderContext, categoryName string) {
	opts := ctx.opts

	// Build the entry line
	var parts []string

	// Description (required)
	desc := e.Description

	// Strip inline attribution if author field is set (to avoid duplication)
	if e.Author != "" {
		desc = stripInlineAttribution(desc, e.Author)
	}

	if e.Breaking && opts.MarkBreakingChanges {
		desc = "**BREAKING:** " + desc
	}
	parts = append(parts, desc)

	// References
	var refs []string
	if e.Issue != "" && opts.IncludeReferences {
		refs = append(refs, formatIssueRef(e.Issue, ctx))
	}
	if e.PR != "" && opts.IncludeReferences {
		refs = append(refs, formatPRRef(e.PR, ctx))
	}
	// Skip commit refs for Highlights - they're meant to be human-readable summaries
	if e.Commit != "" && opts.IncludeReferences && opts.IncludeCommits && categoryName != changelog.CategoryHighlights {
		refs = append(refs, formatCommitRef(e.Commit, ctx))
	}

	// Security metadata
	if categoryName == changelog.CategorySecurity && opts.IncludeSecurityMetadata {
		if e.CVE != "" {
			refs = append(refs, e.CVE)
		}
		if e.GHSA != "" {
			refs = append(refs, e.GHSA)
		}
		if e.Severity != "" {
			refs = append(refs, fmt.Sprintf("severity: %s", e.Severity))
		}
	}

	// Combine parts
	line := strings.Join(parts, " ")
	if len(refs) > 0 {
		line += " (" + strings.Join(refs, ", ") + ")"
	}

	// Author attribution for external contributors
	if opts.IncludeAuthors && e.Author != "" && !ctx.cl.IsTeamMember(e.Author) {
		line += " " + formatAuthorAttribution(e.Author, ctx)
	}

	sb.WriteString("- " + line + "\n")
}

// formatAuthorAttribution formats an author attribution with a GitHub link.
func formatAuthorAttribution(author string, ctx renderContext) string {
	// Normalize author (remove @ if present)
	name := author
	if len(name) > 0 && name[0] == '@' {
		name = name[1:]
	}

	// Create linked attribution if we can determine the host
	if ctx.host == hostGitHub {
		return fmt.Sprintf("by [@%s](https://github.com/%s)", name, name)
	}
	if ctx.host == hostGitLab {
		return fmt.Sprintf("by [@%s](https://gitlab.com/%s)", name, name)
	}

	// Fallback: just show the author name with @ prefix
	return fmt.Sprintf("by @%s", name)
}

// stripInlineAttribution removes inline attribution patterns from a description
// when the username matches the author field. This prevents duplicate attribution
// when the author field is used to generate attribution automatically.
//
// Patterns removed (case-insensitive username matching):
//   - "from [@user](url)"
//   - "by [@user](url)"
//   - "from @user"
//   - "by @user"
//   - "from user"
//   - "by user"
func stripInlineAttribution(desc, author string) string {
	// Normalize author for comparison
	authorNorm := author
	if len(authorNorm) > 0 && authorNorm[0] == '@' {
		authorNorm = authorNorm[1:]
	}

	// Build regex patterns for this author
	// Escape special regex chars in username (though most usernames won't have them)
	escaped := regexp.QuoteMeta(authorNorm)

	// Pattern for linked attribution: (from|by) \[@username\](url)
	linkedPattern := regexp.MustCompile(`(?i)\s*(from|by)\s+\[@?` + escaped + `\]\([^)]+\)\s*$`)
	if linkedPattern.MatchString(desc) {
		return strings.TrimSpace(linkedPattern.ReplaceAllString(desc, ""))
	}

	// Pattern for plain attribution: (from|by) @username or (from|by) username
	plainPattern := regexp.MustCompile(`(?i)\s*(from|by)\s+@?` + escaped + `\s*$`)
	if plainPattern.MatchString(desc) {
		return strings.TrimSpace(plainPattern.ReplaceAllString(desc, ""))
	}

	// Also handle mid-sentence patterns like "fields from [@user](url)"
	// where the attribution is followed by other content - but only strip if at end
	// For safety, we only strip trailing attribution to avoid breaking descriptions

	return desc
}

// formatIssueRef formats an issue reference, optionally with a link.
func formatIssueRef(value string, ctx renderContext) string {
	// If it's already a URL, just use it
	if strings.HasPrefix(value, "http://") || strings.HasPrefix(value, "https://") {
		return fmt.Sprintf("[#%s](%s)", extractNumber(value), value)
	}

	// Strip leading # if present
	num := strings.TrimPrefix(value, "#")

	// If linking enabled and we have a repository
	if ctx.opts.LinkReferences && ctx.baseURL != "" && ctx.host != hostUnknown {
		url := formatIssueURL(ctx.baseURL, ctx.host, num)
		return fmt.Sprintf("[#%s](%s)", num, url)
	}

	return fmt.Sprintf("#%s", num)
}

// formatPRRef formats a PR reference, optionally with a link.
func formatPRRef(value string, ctx renderContext) string {
	// If it's already a URL, just use it
	if strings.HasPrefix(value, "http://") || strings.HasPrefix(value, "https://") {
		return fmt.Sprintf("[#%s](%s)", extractNumber(value), value)
	}

	// Strip leading # if present
	num := strings.TrimPrefix(value, "#")

	// If linking enabled and we have a repository
	if ctx.opts.LinkReferences && ctx.baseURL != "" && ctx.host != hostUnknown {
		url := formatPRURL(ctx.baseURL, ctx.host, num)
		return fmt.Sprintf("[#%s](%s)", num, url)
	}

	return fmt.Sprintf("#%s", num)
}

// formatCommitRef formats a commit reference, optionally with a link.
func formatCommitRef(value string, ctx renderContext) string {
	// Display short hash (first 7 chars) if longer
	shortHash := value
	if len(value) > 7 {
		shortHash = value[:7]
	}

	// If linking enabled and we have a repository
	if ctx.opts.LinkReferences && ctx.baseURL != "" && ctx.host != hostUnknown {
		url := formatCommitURL(ctx.baseURL, ctx.host, value)
		return fmt.Sprintf("[`%s`](%s)", shortHash, url)
	}

	return shortHash
}

// extractNumber extracts the trailing number from a URL like /issues/123
func extractNumber(url string) string {
	parts := strings.Split(url, "/")
	if len(parts) > 0 {
		return parts[len(parts)-1]
	}
	return url
}

// formatIssueURL generates an issue URL for the given host.
func formatIssueURL(baseURL string, host repoHost, num string) string {
	switch host {
	case hostGitLab:
		return fmt.Sprintf("%s/-/issues/%s", baseURL, num)
	default: // hostGitHub
		return fmt.Sprintf("%s/issues/%s", baseURL, num)
	}
}

// formatPRURL generates a PR/MR URL for the given host.
func formatPRURL(baseURL string, host repoHost, num string) string {
	switch host {
	case hostGitLab:
		return fmt.Sprintf("%s/-/merge_requests/%s", baseURL, num)
	default: // hostGitHub
		return fmt.Sprintf("%s/pull/%s", baseURL, num)
	}
}

// formatCommitURL generates a commit URL for the given host.
func formatCommitURL(baseURL string, host repoHost, sha string) string {
	switch host {
	case hostGitLab:
		return fmt.Sprintf("%s/-/commit/%s", baseURL, sha)
	default: // hostGitHub
		return fmt.Sprintf("%s/commit/%s", baseURL, sha)
	}
}

// repoHost represents a supported repository hosting platform.
type repoHost int

const (
	hostUnknown repoHost = iota
	hostGitHub
	hostGitLab
)

// parseRepository extracts the base URL and host type from a repository URL.
func parseRepository(repoURL string) (baseURL string, host repoHost) {
	if matches := githubRepoPattern.FindStringSubmatch(repoURL); matches != nil {
		return fmt.Sprintf("https://github.com/%s/%s", matches[1], matches[2]), hostGitHub
	}
	if matches := gitlabRepoPattern.FindStringSubmatch(repoURL); matches != nil {
		return fmt.Sprintf("https://gitlab.com/%s", matches[1]), hostGitLab
	}
	return "", hostUnknown
}

// renderReferenceLinks generates Keep a Changelog style reference links.
// For GitHub repositories, it creates:
// - Compare links for subsequent releases: /compare/v0.1.0...v0.2.0
// - Tag links for the first release: /releases/tag/v0.1.0
// - Compare to HEAD for unreleased: /compare/v0.2.0...HEAD
// For GitLab repositories, it creates:
// - Compare links for subsequent releases: /-/compare/v0.1.0...v0.2.0
// - Tag links for the first release: /-/tags/v0.1.0
// - Compare to HEAD for unreleased: /-/compare/v0.2.0...HEAD
// If TagPath is set (e.g., "sdk/go"), tags are prefixed: sdk/go/v0.1.0
func renderReferenceLinks(cl *changelog.Changelog, includeUnreleasedLink bool) string {
	baseURL, host := parseRepository(cl.Repository)
	if host == hostUnknown {
		return ""
	}

	var sb strings.Builder

	// Unreleased link (always included by default when there are releases)
	// This lets users see what's been merged since the last release
	if includeUnreleasedLink && len(cl.Releases) > 0 {
		latestVersion := cl.Releases[0].Version
		fmt.Fprintf(&sb, "[unreleased]: %s\n", formatCompareLink(baseURL, host, cl.TagPath, latestVersion, "HEAD"))
	}

	// Release links
	for i, release := range cl.Releases {
		if i == len(cl.Releases)-1 {
			// First/oldest release - link to tag
			fmt.Fprintf(&sb, "[%s]: %s\n", release.Version, formatTagLink(baseURL, host, cl.TagPath, release.Version))
		} else {
			// Subsequent releases - link to compare with previous
			prevVersion := cl.Releases[i+1].Version
			fmt.Fprintf(&sb, "[%s]: %s\n", release.Version, formatCompareLink(baseURL, host, cl.TagPath, prevVersion, release.Version))
		}
	}

	return sb.String()
}

// formatCompareLink generates a comparison URL for the given host.
// Versions are used as-is (no automatic v prefix added).
// If tagPath is non-empty, it's prepended to version tags (e.g., "sdk/go" + "v1.0.0" = "sdk/go/v1.0.0").
func formatCompareLink(baseURL string, host repoHost, tagPath, fromVersion, toVersion string) string {
	fromTag := formatVersionTag(tagPath, fromVersion)
	toTag := formatVersionTag(tagPath, toVersion)
	switch host {
	case hostGitLab:
		return fmt.Sprintf("%s/-/compare/%s...%s", baseURL, fromTag, toTag)
	default: // hostGitHub
		return fmt.Sprintf("%s/compare/%s...%s", baseURL, fromTag, toTag)
	}
}

// formatTagLink generates a tag URL for the given host.
// Versions are used as-is (no automatic v prefix added).
// If tagPath is non-empty, it's prepended to version tags (e.g., "sdk/go" + "v1.0.0" = "sdk/go/v1.0.0").
func formatTagLink(baseURL string, host repoHost, tagPath, version string) string {
	tag := formatVersionTag(tagPath, version)
	switch host {
	case hostGitLab:
		return fmt.Sprintf("%s/-/releases/%s", baseURL, tag)
	default: // hostGitHub
		return fmt.Sprintf("%s/releases/tag/%s", baseURL, tag)
	}
}

// formatVersionTag formats a version with an optional tag path prefix.
// For example, with tagPath="sdk/go" and version="v1.0.0", returns "sdk/go/v1.0.0".
// If tagPath is empty, returns the version unchanged.
// Special case: "HEAD" is never prefixed as it's a git ref, not a version tag.
func formatVersionTag(tagPath, version string) string {
	if tagPath == "" || version == "HEAD" {
		return version
	}
	// Ensure no double slashes
	tagPath = strings.TrimSuffix(tagPath, "/")
	return tagPath + "/" + version
}
