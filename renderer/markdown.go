// Package renderer provides deterministic Markdown rendering for changelogs.
package renderer

import (
	"fmt"
	"regexp"
	"strings"

	"github.com/grokify/structured-changelog/changelog"
)

// githubRepoPattern matches GitHub repository URLs and extracts owner/repo.
var githubRepoPattern = regexp.MustCompile(`^https?://github\.com/([^/]+)/([^/]+?)(?:\.git)?/?$`)

// gitlabRepoPattern matches GitLab repository URLs and extracts the full project path.
// GitLab supports nested groups, so the path can be arbitrarily deep.
var gitlabRepoPattern = regexp.MustCompile(`^https?://gitlab\.com/(.+?)(?:\.git)?/?$`)

// RenderMarkdown renders a changelog to Keep a Changelog formatted Markdown.
// The output is deterministic: same input always produces identical output.
func RenderMarkdown(cl *changelog.Changelog) string {
	return RenderMarkdownWithOptions(cl, DefaultOptions())
}

// renderHeaderLine generates the changelog header line based on project settings.
// It includes references to Keep a Changelog, versioning scheme, commit convention,
// and Structured Changelog as appropriate.
func renderHeaderLine(cl *changelog.Changelog) string {
	var parts []string

	// Always include Keep a Changelog reference
	parts = append(parts, "The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.1.0/)")

	// Add versioning scheme based on the versioning field
	versioning := cl.Versioning
	if versioning == "" {
		versioning = changelog.VersioningSemVer // default
	}

	switch versioning {
	case changelog.VersioningSemVer:
		parts = append(parts, "this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html)")
	case changelog.VersioningCalVer:
		parts = append(parts, "this project uses [Calendar Versioning](https://calver.org/)")
	case changelog.VersioningCustom, changelog.VersioningNone:
		// No versioning line added
	}

	// Add commit convention if specified
	if cl.CommitConvention == changelog.CommitConventionConventional {
		parts = append(parts, "commits follow [Conventional Commits](https://www.conventionalcommits.org/en/v1.0.0/)")
	}

	// Always include Structured Changelog reference
	parts = append(parts, "this changelog is generated by [Structured Changelog](https://github.com/grokify/structured-changelog)")

	// Join parts with appropriate punctuation
	if len(parts) == 1 {
		return parts[0] + ".\n"
	}

	var sb strings.Builder
	for i, part := range parts {
		if i == 0 {
			sb.WriteString(part)
		} else if i == len(parts)-1 {
			sb.WriteString(",\nand ")
			sb.WriteString(part)
		} else {
			sb.WriteString(",\n")
			sb.WriteString(part)
		}
	}
	sb.WriteString(".\n")
	return sb.String()
}

// renderContext holds context needed during rendering.
type renderContext struct {
	opts    Options
	baseURL string
	host    repoHost
}

// RenderMarkdownWithOptions renders a changelog with custom options.
func RenderMarkdownWithOptions(cl *changelog.Changelog, opts Options) string {
	var sb strings.Builder

	// Parse repository for linking
	baseURL, host := parseRepository(cl.Repository)
	ctx := renderContext{
		opts:    opts,
		baseURL: baseURL,
		host:    host,
	}

	// Header
	sb.WriteString("# Changelog\n\n")
	sb.WriteString("All notable changes to this project will be documented in this file.\n\n")
	sb.WriteString(renderHeaderLine(cl))

	// Unreleased section
	if cl.Unreleased != nil && !cl.Unreleased.IsEmpty() {
		sb.WriteString("\n## [Unreleased]\n")
		renderReleaseContent(&sb, cl.Unreleased, ctx)
	}

	// Releases
	for _, release := range cl.Releases {
		sb.WriteString("\n")
		renderRelease(&sb, &release, ctx)
	}

	// Reference links at bottom (for GitHub repositories)
	if opts.IncludeCompareLinks && cl.Repository != "" {
		if links := renderReferenceLinks(cl); links != "" {
			sb.WriteString("\n")
			sb.WriteString(links)
		}
	}

	return sb.String()
}

func renderRelease(sb *strings.Builder, r *changelog.Release, ctx renderContext) {
	// Version header
	if r.Yanked {
		fmt.Fprintf(sb, "## [%s] - %s [YANKED]\n", r.Version, r.Date)
	} else {
		fmt.Fprintf(sb, "## [%s] - %s\n", r.Version, r.Date)
	}

	renderReleaseContent(sb, r, ctx)
}

func renderReleaseContent(sb *strings.Builder, r *changelog.Release, ctx renderContext) {
	// Render categories in canonical order, filtered by tier
	maxTier := ctx.opts.MaxTier
	if maxTier == "" {
		maxTier = changelog.TierOptional
	}

	for _, cat := range r.CategoriesFiltered(maxTier) {
		fmt.Fprintf(sb, "\n### %s\n\n", cat.Name)
		for _, entry := range cat.Entries {
			renderEntry(sb, &entry, ctx, cat.Name == "Security")
		}
	}
}

func renderEntry(sb *strings.Builder, e *changelog.Entry, ctx renderContext, isSecurity bool) {
	opts := ctx.opts

	// Build the entry line
	var parts []string

	// Description (required)
	desc := e.Description
	if e.Breaking && opts.MarkBreakingChanges {
		desc = "**BREAKING:** " + desc
	}
	parts = append(parts, desc)

	// References
	var refs []string
	if e.Issue != "" && opts.IncludeReferences {
		refs = append(refs, formatIssueRef(e.Issue, ctx))
	}
	if e.PR != "" && opts.IncludeReferences {
		refs = append(refs, formatPRRef(e.PR, ctx))
	}
	if e.Commit != "" && opts.IncludeReferences && opts.IncludeCommits {
		refs = append(refs, formatCommitRef(e.Commit, ctx))
	}

	// Security metadata
	if isSecurity && opts.IncludeSecurityMetadata {
		if e.CVE != "" {
			refs = append(refs, e.CVE)
		}
		if e.GHSA != "" {
			refs = append(refs, e.GHSA)
		}
		if e.Severity != "" {
			refs = append(refs, fmt.Sprintf("severity: %s", e.Severity))
		}
	}

	// Combine parts
	line := strings.Join(parts, " ")
	if len(refs) > 0 {
		line += " (" + strings.Join(refs, ", ") + ")"
	}

	sb.WriteString("- " + line + "\n")
}

// formatIssueRef formats an issue reference, optionally with a link.
func formatIssueRef(value string, ctx renderContext) string {
	// If it's already a URL, just use it
	if strings.HasPrefix(value, "http://") || strings.HasPrefix(value, "https://") {
		return fmt.Sprintf("[#%s](%s)", extractNumber(value), value)
	}

	// Strip leading # if present
	num := strings.TrimPrefix(value, "#")

	// If linking enabled and we have a repository
	if ctx.opts.LinkReferences && ctx.baseURL != "" && ctx.host != hostUnknown {
		url := formatIssueURL(ctx.baseURL, ctx.host, num)
		return fmt.Sprintf("[#%s](%s)", num, url)
	}

	return fmt.Sprintf("#%s", num)
}

// formatPRRef formats a PR reference, optionally with a link.
func formatPRRef(value string, ctx renderContext) string {
	// If it's already a URL, just use it
	if strings.HasPrefix(value, "http://") || strings.HasPrefix(value, "https://") {
		return fmt.Sprintf("[#%s](%s)", extractNumber(value), value)
	}

	// Strip leading # if present
	num := strings.TrimPrefix(value, "#")

	// If linking enabled and we have a repository
	if ctx.opts.LinkReferences && ctx.baseURL != "" && ctx.host != hostUnknown {
		url := formatPRURL(ctx.baseURL, ctx.host, num)
		return fmt.Sprintf("[#%s](%s)", num, url)
	}

	return fmt.Sprintf("#%s", num)
}

// formatCommitRef formats a commit reference, optionally with a link.
func formatCommitRef(value string, ctx renderContext) string {
	// Display short hash (first 7 chars) if longer
	shortHash := value
	if len(value) > 7 {
		shortHash = value[:7]
	}

	// If linking enabled and we have a repository
	if ctx.opts.LinkReferences && ctx.baseURL != "" && ctx.host != hostUnknown {
		url := formatCommitURL(ctx.baseURL, ctx.host, value)
		return fmt.Sprintf("[`%s`](%s)", shortHash, url)
	}

	return shortHash
}

// extractNumber extracts the trailing number from a URL like /issues/123
func extractNumber(url string) string {
	parts := strings.Split(url, "/")
	if len(parts) > 0 {
		return parts[len(parts)-1]
	}
	return url
}

// formatIssueURL generates an issue URL for the given host.
func formatIssueURL(baseURL string, host repoHost, num string) string {
	switch host {
	case hostGitLab:
		return fmt.Sprintf("%s/-/issues/%s", baseURL, num)
	default: // hostGitHub
		return fmt.Sprintf("%s/issues/%s", baseURL, num)
	}
}

// formatPRURL generates a PR/MR URL for the given host.
func formatPRURL(baseURL string, host repoHost, num string) string {
	switch host {
	case hostGitLab:
		return fmt.Sprintf("%s/-/merge_requests/%s", baseURL, num)
	default: // hostGitHub
		return fmt.Sprintf("%s/pull/%s", baseURL, num)
	}
}

// formatCommitURL generates a commit URL for the given host.
func formatCommitURL(baseURL string, host repoHost, sha string) string {
	switch host {
	case hostGitLab:
		return fmt.Sprintf("%s/-/commit/%s", baseURL, sha)
	default: // hostGitHub
		return fmt.Sprintf("%s/commit/%s", baseURL, sha)
	}
}

// repoHost represents a supported repository hosting platform.
type repoHost int

const (
	hostUnknown repoHost = iota
	hostGitHub
	hostGitLab
)

// parseRepository extracts the base URL and host type from a repository URL.
func parseRepository(repoURL string) (baseURL string, host repoHost) {
	if matches := githubRepoPattern.FindStringSubmatch(repoURL); matches != nil {
		return fmt.Sprintf("https://github.com/%s/%s", matches[1], matches[2]), hostGitHub
	}
	if matches := gitlabRepoPattern.FindStringSubmatch(repoURL); matches != nil {
		return fmt.Sprintf("https://gitlab.com/%s", matches[1]), hostGitLab
	}
	return "", hostUnknown
}

// renderReferenceLinks generates Keep a Changelog style reference links.
// For GitHub repositories, it creates:
// - Compare links for subsequent releases: /compare/v0.1.0...v0.2.0
// - Tag links for the first release: /releases/tag/v0.1.0
// - Compare to HEAD for unreleased: /compare/v0.2.0...HEAD
// For GitLab repositories, it creates:
// - Compare links for subsequent releases: /-/compare/v0.1.0...v0.2.0
// - Tag links for the first release: /-/tags/v0.1.0
// - Compare to HEAD for unreleased: /-/compare/v0.2.0...HEAD
func renderReferenceLinks(cl *changelog.Changelog) string {
	baseURL, host := parseRepository(cl.Repository)
	if host == hostUnknown {
		return ""
	}

	var sb strings.Builder

	// Unreleased link (if there are releases to compare against)
	if cl.Unreleased != nil && len(cl.Releases) > 0 {
		latestVersion := cl.Releases[0].Version
		fmt.Fprintf(&sb, "[unreleased]: %s\n", formatCompareLink(baseURL, host, latestVersion, "HEAD"))
	}

	// Release links
	for i, release := range cl.Releases {
		if i == len(cl.Releases)-1 {
			// First/oldest release - link to tag
			fmt.Fprintf(&sb, "[%s]: %s\n", release.Version, formatTagLink(baseURL, host, release.Version))
		} else {
			// Subsequent releases - link to compare with previous
			prevVersion := cl.Releases[i+1].Version
			fmt.Fprintf(&sb, "[%s]: %s\n", release.Version, formatCompareLink(baseURL, host, prevVersion, release.Version))
		}
	}

	return sb.String()
}

// formatCompareLink generates a comparison URL for the given host.
func formatCompareLink(baseURL string, host repoHost, fromVersion, toVersion string) string {
	fromRef := fromVersion
	toRef := toVersion
	if fromVersion != "HEAD" {
		fromRef = "v" + fromVersion
	}
	if toVersion != "HEAD" {
		toRef = "v" + toVersion
	}

	switch host {
	case hostGitLab:
		return fmt.Sprintf("%s/-/compare/%s...%s", baseURL, fromRef, toRef)
	default: // hostGitHub
		return fmt.Sprintf("%s/compare/%s...%s", baseURL, fromRef, toRef)
	}
}

// formatTagLink generates a tag URL for the given host.
func formatTagLink(baseURL string, host repoHost, version string) string {
	switch host {
	case hostGitLab:
		return fmt.Sprintf("%s/-/releases/v%s", baseURL, version)
	default: // hostGitHub
		return fmt.Sprintf("%s/releases/tag/v%s", baseURL, version)
	}
}
