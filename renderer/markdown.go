// Package renderer provides deterministic Markdown rendering for changelogs.
package renderer

import (
	"fmt"
	"regexp"
	"strings"

	"github.com/grokify/structured-changelog/changelog"
)

// githubRepoPattern matches GitHub repository URLs and extracts owner/repo.
var githubRepoPattern = regexp.MustCompile(`^https?://github\.com/([^/]+)/([^/]+?)(?:\.git)?/?$`)

// RenderMarkdown renders a changelog to Keep a Changelog formatted Markdown.
// The output is deterministic: same input always produces identical output.
func RenderMarkdown(cl *changelog.Changelog) string {
	return RenderMarkdownWithOptions(cl, DefaultOptions())
}

// RenderMarkdownWithOptions renders a changelog with custom options.
func RenderMarkdownWithOptions(cl *changelog.Changelog, opts Options) string {
	var sb strings.Builder

	// Header
	sb.WriteString("# Changelog\n\n")
	sb.WriteString("All notable changes to this project will be documented in this file.\n\n")
	sb.WriteString("The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.1.0/),\n")
	sb.WriteString("this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html),\n")
	sb.WriteString("and this changelog is generated by [Structured Changelog](https://github.com/grokify/structured-changelog).\n")

	// Unreleased section
	if cl.Unreleased != nil && !cl.Unreleased.IsEmpty() {
		sb.WriteString("\n## [Unreleased]\n")
		renderReleaseContent(&sb, cl.Unreleased, opts)
	}

	// Releases
	for _, release := range cl.Releases {
		sb.WriteString("\n")
		renderRelease(&sb, &release, opts)
	}

	// Reference links at bottom (for GitHub repositories)
	if opts.IncludeCompareLinks && cl.Repository != "" {
		if links := renderReferenceLinks(cl); links != "" {
			sb.WriteString("\n")
			sb.WriteString(links)
		}
	}

	return sb.String()
}

func renderRelease(sb *strings.Builder, r *changelog.Release, opts Options) {
	// Version header
	if r.Yanked {
		fmt.Fprintf(sb, "## [%s] - %s [YANKED]\n", r.Version, r.Date)
	} else {
		fmt.Fprintf(sb, "## [%s] - %s\n", r.Version, r.Date)
	}

	renderReleaseContent(sb, r, opts)
}

func renderReleaseContent(sb *strings.Builder, r *changelog.Release, opts Options) {
	// Render categories in canonical order, filtered by tier
	maxTier := opts.MaxTier
	if maxTier == "" {
		maxTier = changelog.TierOptional
	}

	for _, cat := range r.CategoriesFiltered(maxTier) {
		fmt.Fprintf(sb, "\n### %s\n\n", cat.Name)
		for _, entry := range cat.Entries {
			renderEntry(sb, &entry, opts, cat.Name == "Security")
		}
	}
}

func renderEntry(sb *strings.Builder, e *changelog.Entry, opts Options, isSecurity bool) {
	// Build the entry line
	var parts []string

	// Description (required)
	desc := e.Description
	if e.Breaking && opts.MarkBreakingChanges {
		desc = "**BREAKING:** " + desc
	}
	parts = append(parts, desc)

	// References
	var refs []string
	if e.Issue != "" && opts.IncludeReferences {
		refs = append(refs, formatRef("issue", e.Issue))
	}
	if e.PR != "" && opts.IncludeReferences {
		refs = append(refs, formatRef("PR", e.PR))
	}
	if e.Commit != "" && opts.IncludeReferences && opts.IncludeCommits {
		refs = append(refs, formatRef("commit", e.Commit))
	}

	// Security metadata
	if isSecurity && opts.IncludeSecurityMetadata {
		if e.CVE != "" {
			refs = append(refs, e.CVE)
		}
		if e.GHSA != "" {
			refs = append(refs, e.GHSA)
		}
		if e.Severity != "" {
			refs = append(refs, fmt.Sprintf("severity: %s", e.Severity))
		}
	}

	// Combine parts
	line := strings.Join(parts, " ")
	if len(refs) > 0 {
		line += " (" + strings.Join(refs, ", ") + ")"
	}

	sb.WriteString("- " + line + "\n")
}

func formatRef(refType, value string) string {
	// If it's already a URL, just use it
	if strings.HasPrefix(value, "http://") || strings.HasPrefix(value, "https://") {
		return fmt.Sprintf("[%s](%s)", refType, value)
	}
	// Otherwise, just show the reference
	if strings.HasPrefix(value, "#") {
		return value
	}
	return fmt.Sprintf("#%s", value)
}

// renderReferenceLinks generates Keep a Changelog style reference links.
// For GitHub repositories, it creates:
// - Compare links for subsequent releases: /compare/v0.1.0...v0.2.0
// - Tag links for the first release: /releases/tag/v0.1.0
// - Compare to HEAD for unreleased: /compare/v0.2.0...HEAD
func renderReferenceLinks(cl *changelog.Changelog) string {
	matches := githubRepoPattern.FindStringSubmatch(cl.Repository)
	if matches == nil {
		return ""
	}

	baseURL := fmt.Sprintf("https://github.com/%s/%s", matches[1], matches[2])
	var sb strings.Builder

	// Unreleased link (if there are releases to compare against)
	if cl.Unreleased != nil && len(cl.Releases) > 0 {
		latestVersion := cl.Releases[0].Version
		fmt.Fprintf(&sb, "[unreleased]: %s/compare/v%s...HEAD\n", baseURL, latestVersion)
	}

	// Release links
	for i, release := range cl.Releases {
		if i == len(cl.Releases)-1 {
			// First/oldest release - link to tag
			fmt.Fprintf(&sb, "[%s]: %s/releases/tag/v%s\n", release.Version, baseURL, release.Version)
		} else {
			// Subsequent releases - link to compare with previous
			prevVersion := cl.Releases[i+1].Version
			fmt.Fprintf(&sb, "[%s]: %s/compare/v%s...v%s\n", release.Version, baseURL, prevVersion, release.Version)
		}
	}

	return sb.String()
}
